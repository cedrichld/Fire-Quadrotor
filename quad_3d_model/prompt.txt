FILENAME: quadrotor.py

CONTENTS:


import numpy as np
import matplotlib.pyplot as plt
from numpy.linalg import inv
from numpy.linalg import cholesky
from math import sin, cos, sqrt
import math
from scipy.interpolate import interp1d
from scipy.integrate import ode
from scipy.integrate import solve_ivp
from scipy.linalg import expm, solve_continuous_are

from pydrake.solvers import MathematicalProgram, Solve, OsqpSolver
import pydrake.symbolic as sym

from pydrake.all import MonomialBasis, OddDegreeMonomialBasis, Variables

# Quadrotor Configuration:
# 
#      1:CW    2:CCW
#         \     /
#          \___/
#          /   \
#         /     \
#      4:CCW    3:CW
#

class Quadrotor(object):
  def __init__(self, Q, R, Qf):
    # Parameters
    self.m = 0.698  # quadrotor mass (kg)
    self.g = 9.81   # g (m/s^2)
    self.I = np.diag([3.4e-3, 3.4e-3, 6.0e-3])  # inertia tensor (kg*m^2)
    self.L = 0.171 # arm length (m)
    self.Jtp = 1.302e-6 # Rotational moment of inertia (N*m*s^2 = kg*m^2)
    
    self.ct = (7.6184e-8) * (60 / (2 * np.pi))**2; # Thrust Coef: N*s^2
    self.cq = (2.6839e-9) * (60 / (2 * np.pi))**2; # Torque/Drag Coef: N*m^2
    
    # Control-related parameters
    self.Q = Q       # State cost matrix
    self.R = R       # Input cost matrix
    self.Qf = Qf     # Terminal cost matrix

    # State and control dimensions
    self.n_zeta = 12  # State dimension (x, y, z, phi, theta, psi + their velocities)
    self.n_u = 4      # Input dimension (4 rotors)
    
    # Base omega per motor for hovering (N)
    self.omega_ref = np.sqrt((self.m * self.g) / (self.n_u * self.ct))
    
    # Input limits
    self.omega_min = self.omega_ref * 0.5 # no motor input
    self.omega_max = self.omega_ref * 2 # max rotation speed of 3 times required speed
    
    # X^T = [x, y, z, phi, theta, psi, x_dot, y_dot, z_dot, phi_dot, theta_dot, psi_dot]
    # U^T = [F_z, tau_phi, tau_theta, tau_psi] or [U1, U2, U3, U4]

  def zeta_d(self):
    # Nominal state
    return np.zeros(12)  # Hovering at the origin

  def omega_d(self):
    # Nominal input (hover condition)
    # print(f"u_d is {self.omega_ref * np.ones(self.n_u)}")
    return self.omega_ref * np.ones(self.n_u,)
  
  def U_d(self):
    return np.array([self.m * self.g, 0, 0, 0])
  
  def U_calculator(self, omega):
    U1 = self.ct * (omega[0]**2 + omega[1]**2 + omega[2]**2 + omega[3]**2)
    U2 = self.ct * self.L * (omega[1]**2 - omega[3]**2)
    U3 = self.ct * self.L * (omega[2]**2 - omega[0]**2)
    U4 = self.cq * (-omega[0]**2 + omega[1]**2 - omega[2]**2 + omega[3]**2)
    omega_total = omega[0] - omega[1] + omega[2] - omega[3]
    
    # print(f"U1, U2, U3, U4, omega_total are {U1, U2, U3, U4, omega_total}")
    
    return U1, U2, U3, U4, omega_total

  def continuous_time_full_dynamics(self, zeta, omega):
    '''
    Input: Takes in the current zeta and omega
    Output: Returns the current dzeta
    '''
    # Constants
    m, g, Jtp = self.m, self.g, self.Jtp  # Mass, gravity, torque precession constant
    Ix, Iy, Iz = self.I[0, 0], self.I[1, 1], self.I[2, 2]  # Moments of inertia

    # State: [x, y, z, phi, theta, psi, u, v, w, p, q, r]
    x, y, z = zeta[0:3]
    phi, theta, psi = zeta[3:6] # Euler angles
    u, v, w = zeta[6:9]  # Linear velocities
    p, q, r = zeta[9:12] # Angular velocities
    
    # Input forces and torques
    U1, U2, U3, U4, omega_total = self.U_calculator(omega)
    # print(f"U1, U2, U3, U4, omega_total: {U1, U2, U3, U4, omega_total}")

    # Rotation matrix relating body frame velocities to inertial frame velocities
    R_matrix = np.array([
        [np.cos(theta) * np.cos(psi), 
         np.sin(phi) * np.sin(theta) * np.cos(psi) - np.cos(phi) * np.sin(psi),
         np.cos(phi) * np.sin(theta) * np.cos(psi) + np.sin(phi) * np.sin(psi)],
        [np.cos(theta) * np.sin(psi), 
         np.sin(phi) * np.sin(theta) * np.sin(psi) + np.cos(phi) * np.cos(psi),
         np.cos(phi) * np.sin(theta) * np.sin(psi) - np.sin(phi) * np.cos(psi)],
        [-np.sin(theta), 
         np.sin(phi) * np.cos(theta), 
         np.cos(phi) * np.cos(theta)]
    ])

    # Transformation matrix relating angular velocities to Euler angle derivatives
    T_matrix = np.array([
        [1, np.sin(phi) * np.tan(theta), np.cos(phi) * np.tan(theta)],
        [0, np.cos(phi), -np.sin(phi)],
        [0, np.sin(phi) / np.cos(theta), np.cos(phi) / np.cos(theta)] # May lead to divides by zero
    ])
    
    if np.cos(theta) == 0:
      print("np.cos(theta) is 0!!")

    # Compute nonlinear dynamics
    dzeta = np.zeros(12)
    
    # Position derivatives
    dzeta[0:3] = R_matrix @ np.array([u, v, w])  # [x_dot, y_dot, z_dot]
    
    # Euler angle derivatives
    euler_dots = T_matrix @ np.array([p, q, r])
    dzeta[3] = euler_dots[0]  # phi_dot
    dzeta[4] = euler_dots[1]  # theta_dot
    dzeta[5] = euler_dots[2]  # psi_dot

    # Translational dynamics
    dzeta[6] = (v * r - w * q) + g * np.sin(theta)  # u_dot
    dzeta[7] = (w * p - u * r) - g * np.cos(theta) * np.sin(phi)  # v_dot
    dzeta[8] = (u * q - v * p) - g * np.cos(theta) * np.cos(phi) + U1 / m  # w_dot

    # Rotational dynamics
    dzeta[9] = (q * r * (Iy - Iz) - Jtp * q * omega_total + U2) / Ix  # p_dot
    dzeta[10] = (p * r * (Iz - Ix) + Jtp * p * omega_total + U3) / Iy  # q_dot
    dzeta[11] = (p * q * (Ix - Iy) + U4) / Iz  # r_dot

    return dzeta

  def continuous_time_linearized_dynamics(self):
    """
    Computes the linearized dynamics at the hover point using the hover angular velocity (omega_total)
    and the system parameters.
    
    Parameters:
    - omega_total: Total rotor angular velocity at hover.

    Returns:
    - A: Linearized state matrix (12x12).
    - B: Linearized control matrix (12x4).
    """
    # Unpack parameters
    g = self.g  # Gravity
    m = self.m  # Mass
    Jtp = self.Jtp  # Torque precession constant
    I_x, I_y, I_z = self.I[0, 0], self.I[1, 1], self.I[2, 2]  # Inertia tensor elements
    # _, _, _, _, omega_total = self.U_calculator(omega_current)
    # print(f"omega: {omega}, omega_total: {omega_total}")


    # Initialize A and B matrices
    A = np.zeros((12, 12))
    B = np.zeros((12, 4))

    # Fill A matrix
    # Velocity-to-position coupling
    A[0, 6] = 1  # x_dot coupling with u (x velocity)
    A[1, 7] = 1  # y_dot coupling with v (y velocity)
    A[2, 8] = 1  # z_dot coupling with w (z velocity)
    A[3, 9] = 1  # phi_dot coupling with p (roll rate)
    A[4, 10] = 1  # theta_dot coupling with q (pitch rate)
    A[5, 11] = 1  # psi_dot coupling with r (yaw rate)

    # Gravity coupling
    A[6, 4] = g  # g * theta for x dynamics
    A[7, 3] = -g  # -g * phi for y dynamics
    
    # A[4, 9] = Jtp * omega_total / I_y
    # A[3, 10] = - Jtp * omega_total / I_x

    # Rotational dynamics coupling
    # A[9, 3] = (I_y - I_z) / I_x - Jtp * omega_total / I_x  # Roll dynamics (phi)
    # A[10, 4] = (I_z - I_x) / I_y + Jtp * omega_total / I_y  # Pitch dynamics (theta)
    # A[11, 10] = (I_x - I_y) / I_z  # Yaw dynamics (psi)

    # Fill B matrix
    # Translational dynamics (thrust inputs)
    B[8, 0] = 1 / m
    B[9, 1] = 1 / I_x
    B[10, 2] = 1 / I_y
    B[11, 3] = 1 / I_z

    return A, B

  def discrete_time_linearized_dynamics(self, T):
    # Discrete time version of the linearized dynamics at the fixed point
    # This function returns A and B matrix of the discrete time dynamics
    A_c, B_c = self.continuous_time_linearized_dynamics()
    A_d = np.identity(12) + A_c * T
    B_d = B_c * T

    return A_d, B_d



#############################
# Controls and Optimization #
#############################

  def add_initial_state_constraint(self, prog, zeta, zeta_current):
    # Impose initial state constraint.
    prog.AddBoundingBoxConstraint(zeta_current, zeta_current, zeta[0])
    

  def add_input_saturation_constraint(self, prog, omega, N):
    # Impose input limit constraint.
    for i in range(N - 1):
        prog.AddBoundingBoxConstraint(self.omega_min, self.omega_max, omega[i])

  def add_dynamics_constraint(self, prog, zeta, omega, N, T):
    """
    Adds dynamics constraints to the MPC optimization problem.

    Parameters:
    prog: MathematicalProgram
        The optimization problem.
    zeta: ndarray
        State trajectory decision variables.
    omega: ndarray
        Input trajectory decision variables.
    N: int
        Prediction horizon.
    T: float
        Time step for discretization.
    """
    # Get linearized discrete-time dynamics
    A_d, B_d = self.discrete_time_linearized_dynamics(T)

    # Add constraints for each time step
    for i in range(N - 1):
      dynamics_constraint = (
        zeta[i + 1] - A_d @ zeta[i] - B_d @ omega[i]
      )
      prog.AddLinearEqualityConstraint(
        dynamics_constraint, np.zeros_like(zeta[0])
      )

  def add_cost(self, prog, zeta, omega, N):
    cost = 0
    
    for i in range(N - 1):
      U1, U2, U3, U4, _ = self.U_calculator(omega[i])
      U = np.array([U1, U2, U3, U4])
      cost += (zeta[i] - self.zeta_d()).T @ self.Q @ (zeta[i] - self.zeta_d())
      cost += (U).T @ self.R @ (U)
    # cost += zeta[N - 1].T @ self.Qf @ zeta[N - 1]
    prog.AddQuadraticCost(cost)

  def compute_mpc_feedback(self, zeta_current, use_clf=False):
    '''
    This function computes the MPC controller input omega
    '''

    # Parameters for the QP
    N = 10 # Prediction Horizon
    T = 0.1 # Timestep

    # Initialize mathematical program and decalre decision variables
    prog = MathematicalProgram()

    zeta = np.zeros((N, self.n_zeta), dtype="object")
    for i in range(N):
      zeta[i] = prog.NewContinuousVariables(self.n_zeta, "z_" + str(i))
    omega = np.zeros((N-1, self.n_u), dtype="object")
    for i in range(N-1):
      omega[i] = prog.NewContinuousVariables(self.n_u, "omega_" + str(i))

    # Add constraints and cost
    self.add_initial_state_constraint(prog, zeta, zeta_current)
    self.add_input_saturation_constraint(prog, omega, N)
    self.add_dynamics_constraint(prog, zeta, omega, N, T)
    self.add_cost(prog, zeta, omega, N)

    # Solve the QP
    solver = OsqpSolver()
    result = solver.Solve(prog)

    if result.is_success():
        omega_mpc = result.GetSolution(omega[0])# + self.omega_d()
        # print(f"Control input at this step: {omega_mpc}") 
    else:
        print(f"Solver failed to find a solution at {zeta_current}.")
        # return False
        omega_mpc = np.zeros(self.n_u) 
    
    print(f"result.GetSolution(omega[0]): {result.GetSolution(omega[0])}")
        
    return omega_mpc
  
  
  
  
  
  def rotation_matrix(self, phi, theta, psi):
    # Compute rotation matrix from body to world
    R_x = np.array([
        [1, 0, 0],
        [0, np.cos(phi), -np.sin(phi)],
        [0, np.sin(phi), np.cos(phi)]
    ])
    R_y = np.array([
        [np.cos(theta), 0, np.sin(theta)],
        [0, 1, 0],
        [-np.sin(theta), 0, np.cos(theta)]
    ])
    R_z = np.array([
        [np.cos(psi), -np.sin(psi), 0],
        [np.sin(psi), np.cos(psi), 0],
        [0, 0, 1]
    ])
    R = R_z @ R_y @ R_x  # Combined rotation matrix
    
    return R
  
  def get_motor_positions(self, state):
    X, Y, Z, phi, theta, psi = state[:6]
    # R = self.rotation_matrix(phi, theta, psi)
    motor_offsets = np.array([
        [self.L / 2, 0, 0],  # Motor 1
        [0, self.L / 2, 0],  # Motor 2
        [-self.L / 2, 0, 0],  # Motor 3
        [0, -self.L / 2, 0]  # Motor 4
    ]).T
    return motor_offsets + np.array([[X], [Y], [Z]])



=========================

=========================

=========================


FILENAME: quad_sim.py

CONTENTS:


import numpy as np
from scipy.integrate import solve_ivp
from quadrotor import Quadrotor
from create_animation import animate_quadrotor
import matplotlib.pyplot as plt

def simulate_quadrotor_3d(zeta0, tf, quadrotor, use_mpc=True, use_mpc_with_clf=False, use_clf_qp=False):
  """
  Simulates the stabilized maneuver of a 3D quadrotor system.

  Parameters:
  zeta0 : ndarray
      Initial state vector (12-dimensional for 3D system).
  tf : float
      Simulation end time.
  quadrotor : Quadrotor object
      Quadrotor object containing the dynamics and controllers.
  """
  t0 = 0.0
  dt = 0.01  # Time step for integration

  zeta = [zeta0]
  omega = [np.zeros(quadrotor.n_u)]
  t = [t0]

  while t[-1] < tf:
    current_time = t[-1]
    current_zeta = zeta[-1]
    
    if not np.all(np.isfinite(current_zeta)):
      raise ValueError(f"State vector contains invalid values: {current_zeta}")
    
    print(f"Current_zeta: {np.round(current_zeta, decimals=2)}")

    # Compute remaining time to avoid overshooting
    remaining_time = tf - current_time
    dt = min(dt, remaining_time)  # Adjust dt dynamically

    # print(f"Current time: {current_time}, Remaining time: {remaining_time}, Step size: {dt}")
    # Compute control input
    if use_mpc:
      current_omega_command = quadrotor.compute_mpc_feedback(current_zeta, use_mpc_with_clf)
    elif use_clf_qp:
      current_omega_command = quadrotor.compute_clf_qp_feedback(current_zeta)
    else:
      current_omega_command = quadrotor.compute_lqr_feedback(current_zeta)

    # if (i == False for i in current_omega_command):
    #   print(f"Breaking the MPC Loop. i: {i for i in current_omega_command}")
    #   break
    # Apply input limits
    current_omega_real = np.clip(current_omega_command, quadrotor.omega_min, quadrotor.omega_max)

    # Define ODE for current state
    def f(t, zeta):
      return quadrotor.continuous_time_full_dynamics(current_zeta, current_omega_real)

    # Integrate one time step
    sol = solve_ivp(f, (0, dt), current_zeta, first_step=dt)

    # Record results
    t.append(t[-1] + dt)
    zeta.append(sol.y[:, -1])
    omega.append(current_omega_command)
    
  zeta = np.array(zeta)
  omega = np.array(omega)
  t = np.array(t)

  return zeta, omega, t

def plot_results_3d(zeta, omega, t, name):
  """
  Plots the trajectory and control inputs of the 3D quadrotor.
  """
  plt.figure()
  ax = plt.axes(projection='3d')
  ax.plot3D(zeta[:, 0], zeta[:, 1], zeta[:, 2], label="Trajectory")
  ax.scatter(zeta[0, 0], zeta[0, 1], zeta[0, 2], color='red', label="Start")
  ax.scatter(zeta[-1, 0], zeta[-1, 1], zeta[-1, 2], color='green', label="End")
  ax.set_xlabel("X (m)")
  ax.set_ylabel("Y (m)")
  ax.set_zlabel("Z (m)")
  ax.legend()
  ax.set_title(f"3D Trajectory ({name})")
  plt.savefig(f"{name}_trajectory.png") 
  print(f"Saved trajectory plot as {name}_trajectory.png")

  plt.figure()
  plt.plot(t[1:], omega[1:])
  plt.xlabel("Time (s)")
  plt.ylabel("Control Inputs (N)")
  plt.title(f"Control Inputs ({name})")
  plt.legend([f"omega{i+1}" for i in range(omega.shape[1])])
  # plt.show()
  plt.savefig(f"{name}_inputs.png")
  print(f"Saved input plot as {name}_inputs.png")

if __name__ == '__main__':
  # Define system parameters
  # R = np.eye(4)
  # Q = np.diag([10, 10, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1])
  R = np.diag([0.1, 10, 100, 10])
  Q = np.eye(12) * 0.1
  Qf = Q

  quadrotor = Quadrotor(Q, R, Qf)

  # Initial state (position, orientation, velocities)
  zeta0 = np.array([0.5, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0])  # Hovering at 0.5m

  # Simulation duration
  tf = 10.0

  # Simulate the quadrotor
  zeta, omega, t = simulate_quadrotor_3d(zeta0, tf, quadrotor)

  # Plot results
  plot_results_3d(zeta, omega, t, "3D Quadrotor")

  # Animate the quadrotor
  animate_quadrotor(zeta, t, Q, R, Qf)



=========================

=========================

=========================


FILENAME: Matlab/Feedback_Linearization.m

CONTENTS:


%% Project Made By HERAZ Walid as a bachelor graduation project at the Institute of Electrical and Electronic Engineering IGEE_ex_INELEC 2024, Algeria
%% Github : https://github.com/HerazWalid
%% LinkdIn : https://www.linkedin.com/in/walid-heraz-94337a240/



function [Phi_ref, Theta_ref, U1]=Feedback_Linearization(X_ref,X_dot_ref,X_dot_dot_ref,Y_ref,Y_dot_ref,Y_dot_dot_ref,Z_ref,Z_dot_ref,Z_dot_dot_ref,Psi_ref,states)


%% Load the constants
constants=init_constants();
m  = constants{4};
g  = constants{5};
px=constants{17};
py=constants{18};
pz=constants{19};

%% Assign the states
% States: [u,v,w,p,q,r,x,y,z,phi,theta,psi]

u = states(1);
v = states(2);
w = states(3);
x = states(7);
y = states(8);
z = states(9);
phi = states(10);
theta = states(11);
psi = states(12);

% Rotational matrix that relates u,v,w with x_dot,y_dot,z_dot
R_matrix=[cos(theta)*cos(psi), sin(phi)*sin(theta)*cos(psi)-cos(phi)*sin(psi), ...
    cos(phi)*sin(theta)*cos(psi)+sin(phi)*sin(psi); ...
    cos(theta)*sin(psi), sin(phi)*sin(theta)*sin(psi)+cos(phi)*cos(psi), ...
    cos(phi)*sin(theta)*sin(psi)-sin(phi)*cos(psi); ...
    -sin(theta), sin(phi)*cos(theta), cos(phi)*cos(theta)];

x_dot=R_matrix(1,:)*[u;v;w]; %x_dot
y_dot=R_matrix(2,:)*[u;v;w]; %y_dot
z_dot=R_matrix(3,:)*[u;v;w]; %z_dot

%% Compute the errors
ex=X_ref-x;
ex_dot=X_dot_ref-x_dot;
ey=Y_ref-y;
ey_dot=Y_dot_ref-y_dot;
ez=Z_ref-z;
ez_dot=Z_dot_ref-z_dot;

%% Compute the the constants Kp, Kd, and the values vx, vy, vz to stabilize the position subsystem
kx1=(px(1)-(px(1)+px(2))/2).^2-(px(1)+px(2)).^2/4;
kx2=px(1)+px(2);
kx1=real(kx1);
kx2=real(kx2);

ky1=(py(1)-(py(1)+py(2))/2).^2-(py(1)+py(2)).^2/4;
ky2=py(1)+py(2);
ky1=real(ky1);
ky2=real(ky2);

kz1=(pz(1)-(pz(1)+pz(2))/2).^2-(pz(1)+pz(2)).^2/4;
kz2=pz(1)+pz(2);
kz1=real(kz1);
kz2=real(kz2);



% Compute the values vx, vy, vz for the position controller

ux=kx1*ex + kx2*ex_dot ;
uy=ky1*ey + ky2*ey_dot ;
uz=kz1*ez + kz2*ez_dot ;

 
%% Continue here
vx=X_dot_dot_ref-ux;
vy=Y_dot_dot_ref-uy;
vz=Z_dot_dot_ref-uz;

%% Compute phi, theta, U1
a=vx/(vz+g);
b=vy/(vz+g);
c=cos(Psi_ref);
d=sin(Psi_ref);
tan_theta=a*c+b*d;
Theta_ref=atan(tan_theta);

if Psi_ref>=0
    Psi_ref_singularity=Psi_ref-floor(abs(Psi_ref)/(2*pi))*2*pi;
else
    Psi_ref_singularity=Psi_ref+floor(abs(Psi_ref)/(2*pi))*2*pi;
end


if or(or(abs(Psi_ref_singularity)<pi/4,abs(Psi_ref_singularity)>7*pi/4), ...
        and(abs(Psi_ref_singularity)>3*pi/4,abs(Psi_ref_singularity)<5*pi/4))
    tan_phi=cos(Theta_ref)*(tan(Theta_ref)*d-b)/c;
else
    tan_phi=cos(Theta_ref)*(a-tan(Theta_ref)*c)/d;
end

Phi_ref=atan(tan_phi);
U1=(vz+g)*m/(cos(Phi_ref)*cos(Theta_ref));

end



=========================

=========================

=========================


FILENAME: Matlab/LPV.m

CONTENTS:


%% Project Made By HERAZ Walid as a bachelor graduation project at the Institute of Electrical and Electronic Engineering IGEE_ex_INELEC 2024, Algeria
%% Github : https://github.com/HerazWalid
%% LinkdIn : https://www.linkedin.com/in/walid-heraz-94337a240/



function [Ad, Bd, Cd, Dd, x_dot, y_dot, z_dot, phi, phi_dot, theta, theta_dot, psi, psi_dot] = LPV(states)
    % This is an LPV model concerning the three rotational axis.

    % Get the constants from the general pool of constants
    constants = init_constants();
    Ix = constants{1}; %kg*m^2
    Iy = constants{2}; %kg*m^2
    Iz  = constants{3}; %kg*m^2
    Jtp=constants{6}; %N*m*s^2=kg*m^2
    Ts=constants{7}; %s


    % Assign the states
    % States: [u,v,w,p,q,r,x,y,z,phi,theta,psi]
    u = states(1);
    v = states(2);
    w = states(3);
    p = states(4);
    q = states(5);
    r = states(6);
    phi = states(10);
    theta = states(11);
    psi = states(12);

    global omega_total;

    %%

    % Rotational matrix that relates u,v,w with x_dot,y_dot,z_dot
    R_matrix=[cos(theta)*cos(psi), sin(phi)*sin(theta)*cos(psi)-cos(phi)*sin(psi), ...
        cos(phi)*sin(theta)*cos(psi)+sin(phi)*sin(psi); ...
        cos(theta)*sin(psi), sin(phi)*sin(theta)*sin(psi)+cos(phi)*cos(psi), ...
        cos(phi)*sin(theta)*sin(psi)-sin(phi)*cos(psi); ...
        -sin(theta), sin(phi)*cos(theta), cos(phi)*cos(theta)];

    x_dot=R_matrix(1,:)*[u;v;w]; %x_dot
    y_dot=R_matrix(2,:)*[u;v;w]; %y_dot
    z_dot=R_matrix(3,:)*[u;v;w]; %z_dot

    % To get phi_dot, theta_dot, psi_dot, you need the T matrix

    % Transformation matrix that relates p,q,r with phi_dot,theta_dot,psi_dot
    T_matrix=[1, sin(phi)*tan(theta), cos(phi)*tan(theta); ...
        0, cos(phi), -sin(phi); ...
        0, sin(phi)*sec(theta), cos(phi)*sec(theta)];

    phi_dot=T_matrix(1,:)*[p;q;r]; %phi_dot
    theta_dot=T_matrix(2,:)*[p;q;r]; %theta_dot
    psi_dot=T_matrix(3,:)*[p;q;r]; %psi_dot

    A12=1;
    A24=-omega_total*Jtp/Ix;
    A26=theta_dot*(Iy-Iz)/Ix;
    A34=1;
    A42=omega_total*Jtp/Iy;
    A46=phi_dot*(Iz-Ix)/Iy;
    A56=1;
    A62=(theta_dot/2)*(Ix-Iy)/Iz;
    A64=(phi_dot/2)*(Ix-Iy)/Iz;

    A = [0  A12   0   0     0   0;
         0  0     0   A24   0   A26;
         0  0     0   A34   0   0;
         0  A42   0   0     0   A46;
         0  0     0   0     0   A56;
         0  A62   0   A64   0   0];


    B = [ 0       0     0    ;
          1/Ix    0     0    ;
          0       0     0    ;
          0       1/Iy  0    ;
          0       0     0    ;
          0       0     1/Iz];

    C = [1 0 0 0 0 0;0 0 1 0 0 0;0 0 0 0 1 0];

    D=zeros(3);


    % Discretize the system

    % Forward Euler
    Ad=eye(length(A(1,:)))+Ts*A;
    Bd=Ts*B;
    Cd=C;
    Dd=D;


end




=========================

=========================

=========================


FILENAME: Matlab/MAIN.m

CONTENTS:


%% Project Made By HERAZ Walid as a bachelor graduation project at the Institute of Electrical and Electronic Engineering IGEE_ex_INELEC 2024, Algeria
%% Github : https://github.com/HerazWalid
%% LinkdIn : https://www.linkedin.com/in/walid-heraz-94337a240/
%% 

clear all
close all
clc
echo off
warning off


%% Load the constant values
constants=init_constants();
Ts=constants{7};
controlled_states=constants{14}; % number of controlled states in this script
innerDyn_length=constants{16}; % Number of inner control loop iterations

%% Generate the reference signals
t = 0:Ts*innerDyn_length:100;
t_angles=(0:Ts:t(end))';
r = 2;
f=0.025;
height_i=2;
height_f=5;
[X_ref,X_dot_ref,X_dot_dot_ref,Y_ref,Y_dot_ref,Y_dot_dot_ref,Z_ref,Z_dot_ref,Z_dot_dot_ref,psi_ref]=trajectory_generator(t,r,f,height_i,height_f);
plotl=length(t); % Number of outer control loop iterations


%% Define design parameters
D2R = pi/180;
R2D = 180/pi;
b   = 0.6;   % the length of total square cover by whole body of quadcopter in meter
a   = b/3;   % the legth of small square base of quadcopter(b/4)
H   = 0.06;  % hight of drone in Z direction 
H_m = H+H/2; % hight of motor in z direction
r_p = b/4;   % radius of propeller
%% Conversions
ro = 45*D2R;                   % angle by which rotate the base of quadcopter
Ri = [cos(ro) -sin(ro) 0;
      sin(ro) cos(ro)  0;
       0       0       1];     % rotation matrix to rotate the coordinates of base 
base_co = [-a/2  a/2 a/2 -a/2; % Coordinates of Base 
           -a/2 -a/2 a/2 a/2;
             0    0   0   0];
base = Ri*base_co;             % rotate base Coordinates by 45 degree 

to = linspace(0, 2*pi);
xp = r_p*cos(to);
yp = r_p*sin(to);
zp = zeros(1,length(to));



%% Load the initial state vector

ut=0;
vt=0;
wt=0;
pt=0;
qt=0;
rt=0;
xt=0;
yt=0; % Initial translational position
zt=0; % Initial translational position
phit=0;    % Initial angular position
thetat=0;  % Initial angular position
psit=psi_ref(1,2);    % Initial angular position

states=[ut,vt,wt,pt,qt,rt,xt,yt,zt,phit,thetat,psit];
states_total=states;

% Assume that first Phi_ref, Theta_ref, Psi_ref are equal to the first
% phit, thetat, psit
ref_angles_total=[phit,thetat,psit];
velocityXYZ_total=[X_dot_ref(1,2),Y_dot_ref(1,2),Z_dot_ref(1,2)];


%% Initial drone state

omega1=110*pi/3; % rad/s
omega2=110*pi/3; % rad/s
omega3=110*pi/3; % rad/s
omega4=110*pi/3; % rad/s 

ct = constants{11};
cq = constants{12};
l  = constants{13};

U1=ct*(omega1^2+omega2^2+omega3^2+omega4^2);
U2=ct*l*(omega2^2-omega4^2);
U3=ct*l*(omega3^2-omega1^2); 
U4=cq*(-omega1^2+omega2^2-omega3^2+omega4^2);

UTotal=[U1,U2,U3,U4];% 4 inputs

global omega_total
omega_total=omega1-omega2+omega3-omega4;

%% Start the global controller

for i_global = 1:plotl-1


    %% Implement the position controller (state feedback linearization)

    [phi_ref, theta_ref, U1]=Feedback_Linearization(X_ref(i_global+1,2),X_dot_ref(i_global+1,2),X_dot_dot_ref(i_global+1,2),Y_ref(i_global+1,2),Y_dot_ref(i_global+1,2),Y_dot_dot_ref(i_global+1,2),Z_ref(i_global+1,2),Z_dot_ref(i_global+1,2),Z_dot_dot_ref(i_global+1,2),psi_ref(i_global+1,2),states);


    Phi_ref=phi_ref*ones(innerDyn_length+1,1);
    Theta_ref=theta_ref*ones(innerDyn_length+1,1);
    
    
    % Make Psi_ref increase continuosly in a linear fashion per outer loop
    Psi_ref=zeros(innerDyn_length+1,1);
    for yaw_step = 1:(innerDyn_length+1)
        Psi_ref(yaw_step)=psi_ref(i_global,2)+(psi_ref(i_global+1,2)-psi_ref(i_global,2))/(Ts*innerDyn_length)*Ts*(yaw_step-1);
    end
    
    ref_angles_total=[ref_angles_total;Phi_ref(2:end) Theta_ref(2:end) Psi_ref(2:end)];

    %% Create the reference vector

    refSignals=zeros(length(Phi_ref(:,1))*controlled_states,1);
    % Format: refSignals=[Phi_ref;Theta_ref;Psi_ref;Phi_ref; ... etc] x inner
    % loop frequency per one set of position controller outputs
    k_ref_local=1;
    for i = 1:controlled_states:length(refSignals)
       refSignals(i)=Phi_ref(k_ref_local,1);
       refSignals(i+1)=Theta_ref(k_ref_local,1);
       refSignals(i+2)=Psi_ref(k_ref_local,1);
       k_ref_local=k_ref_local+1;
    end

    k_ref_local=1; % for reading reference signals
    hz = constants{15}; % horizon period
    for i =1:innerDyn_length
        %% Generate discrete LPV Ad, Bd, Cd, Dd matrices
        [Ad, Bd, Cd, Dd, x_dot, y_dot, z_dot, phit, phi_dot, thetat, theta_dot, psit, psi_dot]=LPV(states);
        velocityXYZ_total=[velocityXYZ_total;[x_dot, y_dot, z_dot]];


        %% Generating the current state and the reference vector
        x_aug_t=[phit;phi_dot;thetat;theta_dot;psit;psi_dot;U2;U3;U4];

        k_ref_local=k_ref_local+controlled_states;

        % Start counting from the second sample period:
        % r=refSignals(Phi_ref_2;Theta_ref_2;Psi_ref_2;Phi_ref_3...) etc.
        if k_ref_local+controlled_states*hz-1 <= length(refSignals)
            r=refSignals(k_ref_local:k_ref_local+controlled_states*hz-1);
        else
            r=refSignals(k_ref_local:length(refSignals));
            hz=hz-1;
        end

        %% Generate simplification matrices for the cost function
        [Hdb,Fdbt,Cdb,Adc] = MPC(Ad,Bd,Cd,Dd,hz);

        %% Calling the optimizer (quadprog)

        % Cost function in quadprog: min(du)*1/2*du'Hdb*du+f'du
        ft=[x_aug_t',r']*Fdbt;

        % normalement Hdb should be positive so we check if matrix Hdb in the cost function is positive definit.
        [~,p] = chol(Hdb);
        if p~=0
           disp('Hdb is NOT positive definite');
        end

   
        [du,fval]=quadprog(Hdb,ft);
        
        % Update the real inputs
        U2=U2+du(1);
        U3=U3+du(2);
        U4=U4+du(3);

        UTotal=[UTotal;U1,U2,U3,U4];

        % Compute the new omegas based on the new U-s.
        U1C=U1/ct;
        U2C=U2/(ct*l);
        U3C=U3/(ct*l);
        U4C=U4/cq;
        
        omega_Matrix=[1 1 1 1;0 1 0 -1;-1 0 1 0;-1 1 -1 1];
        UC_vector=[U1C;U2C;U3C;U4C];
        omegas_vector=inv(omega_Matrix)*UC_vector;

        omega1=sqrt(omegas_vector(1));
        omega2=sqrt(omegas_vector(2));
        omega3=sqrt(omegas_vector(3));
        omega4=sqrt(omegas_vector(4));

        % Compute the total omega
        omega_total=omega1-omega2+omega3-omega4;

        % Simulate the new states
        T = (Ts)*(i-1):(Ts)/30:Ts*(i-1)+(Ts);
        [T,x]=ode45(@(t,x) drone_plant(t,x,[U1,U2,U3,U4]),T,states);
        states=x(end,:);
        disp('Final states:');
        disp(size(states_total));
        states_total=[states_total;states];

        imaginary_check=imag(states)~=0;
        imaginary_check_sum=sum(imaginary_check);
        if imaginary_check_sum~=0
            disp('Imaginary part exists - something is wrong');
        end
    end
end







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Plot the trajectory
% States: [u,v,w,p,q,r,X,Y,Z,phi,theta,psi] we found them all

% Plot the trajectory
figure;
hg   = gca;
grid on;
view(3);
xlabel('X[m]','FontSize',15);
ylabel('Y[m]','FontSize',15);
zlabel('Z[m]','FontSize',15);
hold(gca, 'on');



%% Design Different parts
% design the base square
 drone(1) = patch([base(1,:)],[base(2,:)],[base(3,:)],'r');
 drone(2) = patch([base(1,:)],[base(2,:)],[base(3,:)+H],'r');
 alpha(drone(1:2),0.7);
% design 2 parpendiculer legs of quadcopter 
 [xcylinder, ycylinder, zcylinder] = cylinder([H/2 H/2]);
 drone(3) =  surface(b*zcylinder-b/2,ycylinder,xcylinder+H/2,'facecolor','b');
 drone(4) =  surface(ycylinder,b*zcylinder-b/2,xcylinder+H/2,'facecolor','b') ; 
 alpha(drone(3:4),0.6);
% design 4 cylindrical motors 
 drone(5) = surface(xcylinder+b/2,ycylinder,H_m*zcylinder+H/2,'facecolor','r');
 drone(6) = surface(xcylinder-b/2,ycylinder,H_m*zcylinder+H/2,'facecolor','r');
 drone(7) = surface(xcylinder,ycylinder+b/2,H_m*zcylinder+H/2,'facecolor','r');
 drone(8) = surface(xcylinder,ycylinder-b/2,H_m*zcylinder+H/2,'facecolor','r');
 alpha(drone(5:8),0.7);
% design 4 propellers
 drone(9)  = patch(xp+b/2,yp,zp+(H_m+H/2),'c','LineWidth',0.5);
 drone(10) = patch(xp-b/2,yp,zp+(H_m+H/2),'c','LineWidth',0.5);
 drone(11) = patch(xp,yp+b/2,zp+(H_m+H/2),'p','LineWidth',0.5);
 drone(12) = patch(xp,yp-b/2,zp+(H_m+H/2),'p','LineWidth',0.5);
 alpha(drone(9:12),0.3);

%% create a group object and parent surface
  combinedobject = hgtransform('parent',hg );
  set(drone,'parent',combinedobject)


% Initialize plot handles
trajectory_ref = plot3(X_ref(:,2), Y_ref(:,2), Z_ref(:,2), '--b', 'LineWidth', 3);
hold on;


% Extracting position information for plotting the quadrotor
x = states_total(1:innerDyn_length:end,7);
y = states_total(1:innerDyn_length:end,8);
z = states_total(1:innerDyn_length:end,9);
roll = states_total(1:innerDyn_length:end,10);
pitch = states_total(1:innerDyn_length:end,11);
yaw = states_total(1:innerDyn_length:end,12);


 for i = 1:length(x)
     hold on;
     ba = plot3(x(1:i),y(1:i),z(1:i), 'r:','LineWidth',3);
     disp(states_total(:, 7:12));

     translation = makehgtform('translate',...
                               [x(i) y(i) z(i)]);
     rotation1 = makehgtform('xrotate',(pi/180)*(roll(i)));
     rotation2 = makehgtform('yrotate',(pi/180)*(pitch(i)));
     rotation3 = makehgtform('zrotate',yaw(i));
     %scaling = makehgtform('scale',1-i/20);
     set(combinedobject,'matrix',...
          translation*rotation3*rotation2*rotation1);
     drawnow
    pause(0.09);
 end










 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Plot the positions and velocities individually

% X and X_dot
figure;
subplot(2,1,1)
plot(t(1:plotl),X_ref(1:plotl,2),'--b','LineWidth',2)
hold on
subplot(2,1,1)
plot(t(1:plotl),states_total(1:innerDyn_length:end,7),'r','LineWidth',1)
grid on
xlabel('time [s]','FontSize',15)
ylabel('x-position [m]','FontSize',15)
legend({'x-ref','x-position'},'Location','northeast','FontSize',15)
subplot(2,1,2)
plot(t(1:plotl),X_dot_ref(1:plotl,2),'--b','LineWidth',2)
hold on
subplot(2,1,2)
plot(t(1:plotl),velocityXYZ_total(1:innerDyn_length:end,1),'r','LineWidth',1)
grid on
xlabel('time [s]','FontSize',15)
ylabel('x-velocity [m/s]','FontSize',15)
legend({'x-dot-ref','x-velocity'},'Location','northeast','FontSize',15)

% Y and Y_dot
figure;
subplot(2,1,1)
plot(t(1:plotl),Y_ref(1:plotl,2),'--b','LineWidth',2)
hold on
subplot(2,1,1)
plot(t(1:plotl),states_total(1:innerDyn_length:end,8),'r','LineWidth',1)
grid on
xlabel('time [s]','FontSize',15)
ylabel('y-position [m]','FontSize',15)
legend({'y-ref','y-position'},'Location','northeast','FontSize',15)
subplot(2,1,2)
plot(t(1:plotl),Y_dot_ref(1:plotl,2),'--b','LineWidth',2)
hold on
subplot(2,1,2)
plot(t(1:plotl),velocityXYZ_total(1:innerDyn_length:end,2),'r','LineWidth',1)
grid on
xlabel('time [s]','FontSize',15)
ylabel('y-velocity [m/s]','FontSize',15)
legend({'y-dot-ref','y-velocity'},'Location','northeast','FontSize',15)

% Z and Z_dot
figure;
subplot(2,1,1)
plot(t(1:plotl),Z_ref(1:plotl,2),'--b','LineWidth',2)
hold on
subplot(2,1,1)
plot(t(1:plotl),states_total(1:innerDyn_length:end,9),'r','LineWidth',1)
grid on
xlabel('time [s]','FontSize',15)
ylabel('z-position [m]','FontSize',15)
legend({'z-ref','z-position'},'Location','northeast','FontSize',15)
subplot(2,1,2)
plot(t(1:plotl),Z_dot_ref(1:plotl,2),'--b','LineWidth',2)
hold on
subplot(2,1,2)
plot(t(1:plotl),velocityXYZ_total(1:innerDyn_length:end,3),'r','LineWidth',1)
grid on
xlabel('time [s]','FontSize',15)
ylabel('z-velocity [m/s]','FontSize',15)
legend({'z-dot-ref','z-velocity'},'Location','northeast','FontSize',15)

%% Plot the angles individually

% Phi
figure;
subplot(3,1,1)
plot(t_angles(1:length(ref_angles_total(:,1))),ref_angles_total(:,1),'--b','LineWidth',2)
hold on
subplot(3,1,1)
plot(t_angles(1:length(states_total(:,10))),states_total(:,10),'r','LineWidth',1)
grid on
xlabel('time [s]','FontSize',15)
ylabel('phi-angle [rad]','FontSize',15)
legend({'phi-ref','phi-angle'},'Location','northeast','FontSize',15)

% Theta
subplot(3,1,2)
plot(t_angles(1:length(ref_angles_total(:,2))),ref_angles_total(:,2),'--b','LineWidth',2)
hold on
subplot(3,1,2)
plot(t_angles(1:length(states_total(:,11))),states_total(:,11),'r','LineWidth',1)
grid on
xlabel('time [s]','FontSize',15)
ylabel('theta-angle [rad]','FontSize',15)
legend({'theta-ref','theta-angle'},'Location','northeast','FontSize',15)

% Psi
subplot(3,1,3)
plot(t_angles(1:length(ref_angles_total(:,3))),ref_angles_total(:,3),'--b','LineWidth',2)
hold on
subplot(3,1,3)
plot(t_angles(1:length(states_total(:,12))),states_total(:,12),'r','LineWidth',1)
grid on
xlabel('time [s]','FontSize',15)
ylabel('psi-angle [rad]','FontSize',15)
legend({'psi-ref','psi-angle'},'Location','northeast','FontSize',15)


%% Plot the inputs

figure
subplot(4,1,1)
plot(t_angles(1:length(states_total(:,10))),UTotal(:,1))
grid on
xlabel('time [s]','FontSize',15)
ylabel('U1 [N]','FontSize',15)
subplot(4,1,2)
plot(t_angles(1:length(states_total(:,10))),UTotal(:,2))
grid on
xlabel('time [s]','FontSize',15)
ylabel('U2 [Nm]','FontSize',15)
subplot(4,1,3)
plot(t_angles(1:length(states_total(:,10))),UTotal(:,3))
grid on
xlabel('time [s]','FontSize',15)
ylabel('U3 [Nm]','FontSize',15)
subplot(4,1,4)
plot(t_angles(1:length(states_total(:,10))),UTotal(:,4))
grid on
xlabel('time [s]','FontSize',15)
ylabel('U4 [Nm]','FontSize',15)




=========================

=========================

=========================


FILENAME: Matlab/MPC.m

CONTENTS:


%% Project Made By HERAZ Walid as a bachelor graduation project at the Institute of Electrical and Electronic Engineering IGEE_ex_INELEC 2024, Algeria
%% Github : https://github.com/HerazWalid
%% LinkdIn : https://www.linkedin.com/in/walid-heraz-94337a240/




function [Hdb,Fdbt,Cdb,Adc] = MPC(Ad,Bd,Cd,Dd,hz)
    
    % db - double bar
    % dbt - double bar transpose
    % dc - double circumflex
    
    A_aug=[Ad,Bd;zeros(length(Bd(1,:)),length(Ad(1,:))),eye(length(Bd(1,:)))];
    B_aug=[Bd;eye(length(Bd(1,:)))];
    C_aug=[Cd,zeros(length(Cd(:,1)),length(Bd(1,:)))];
    D_aug=Dd; % D_aug is not used because it is a zero matrix
    
    constants = init_constants();
    Q = constants{8};
    S = constants{9};
    R  = constants{10};
    
    CQC=C_aug'*Q*C_aug;
    CSC=C_aug'*S*C_aug;
    QC=Q*C_aug;
    SC=S*C_aug;
    
    Qdb=zeros(length(CQC(:,1))*hz,length(CQC(1,:))*hz);
    Tdb=zeros(length(QC(:,1))*hz,length(QC(1,:))*hz);
    Rdb=zeros(length(R(:,1))*hz,length(R(1,:))*hz);
    Cdb=zeros(length(B_aug(:,1))*hz,length(B_aug(1,:))*hz);
    Adc=zeros(length(A_aug(:,1))*hz,length(A_aug(1,:)));
    
    for i = 1:hz
        
       if i == hz
           Qdb(1+length(CSC(:,1))*(i-1):length(CSC(:,1))*i,1+length(CSC(1,:))*(i-1):length(CSC(1,:))*i)=CSC;
           Tdb(1+length(SC(:,1))*(i-1):length(SC(:,1))*i,1+length(SC(1,:))*(i-1):length(SC(1,:))*i)=SC;           
       else
           Qdb(1+length(CQC(:,1))*(i-1):length(CQC(:,1))*i,1+length(CQC(1,:))*(i-1):length(CQC(1,:))*i)=CQC;
           Tdb(1+length(QC(:,1))*(i-1):length(QC(:,1))*i,1+length(QC(1,:))*(i-1):length(QC(1,:))*i)=QC;
       end
       
       Rdb(1+length(R(:,1))*(i-1):length(R(:,1))*i,1+length(R(1,:))*(i-1):length(R(1,:))*i)=R;
       
       for j = 1:hz
           if j<=i
               Cdb(1+length(B_aug(:,1))*(i-1):length(B_aug(:,1))*i,1+length(B_aug(1,:))*(j-1):length(B_aug(1,:))*j)=A_aug^(i-j)*B_aug;
           end
       end
       Adc(1+length(A_aug(:,1))*(i-1):length(A_aug(:,1))*i,1:length(A_aug(1,:)))=A_aug^(i);
    end
    Hdb=Cdb'*Qdb*Cdb+Rdb;
    Fdbt=[Adc'*Qdb*Cdb;-Tdb*Cdb];
end



=========================

=========================

=========================


FILENAME: Matlab/drone_plant.m

CONTENTS:


%% Project Made By HERAZ Walid as a bachelor graduation project at the Institute of Electrical and Electronic Engineering IGEE_ex_INELEC 2024, Algeria
%% Github : https://github.com/HerazWalid
%% LinkdIn : https://www.linkedin.com/in/walid-heraz-94337a240/


function dx = drone_plant(~, states, U) 
    
    % Constants
    constants = init_constants();
    Ix = constants{1}; %kg*m^2
    Iy = constants{2}; %kg*m^2
    Iz  = constants{3}; %kg*m^2
    m  = constants{4}; %kg
    g  = constants{5}; %m/s^2
    Jtp=constants{6}; %N*m*s^2=kg*m^2
    
    % States: [u,v,w,p,q,r,x,y,z,phi,theta,psi]
    u = states(1);
    v = states(2);
    w = states(3);
    p = states(4);
    q = states(5);
    r = states(6);
  % x = states(7);
  % y = states(8);
  % z = states(9);
    phi = states(10);
    theta = states(11);
    psi = states(12);
    

    % Inputs:
    
    U1  = U(1);
    U2  = U(2);
    U3  = U(3);
    U4  = U(4);
    
    
    % Rotational matrix that relates u,v,w with x_dot,y_dot,z_dot
    R_matrix=[cos(theta)*cos(psi), sin(phi)*sin(theta)*cos(psi)-cos(phi)*sin(psi), ...
        cos(phi)*sin(theta)*cos(psi)+sin(phi)*sin(psi); ...
        cos(theta)*sin(psi), sin(phi)*sin(theta)*sin(psi)+cos(phi)*cos(psi), ...
        cos(phi)*sin(theta)*sin(psi)-sin(phi)*cos(psi); ...
        -sin(theta), sin(phi)*cos(theta), cos(phi)*cos(theta)];
    
    % Transformation matrix that relates p,q,r with phi_dot,theta_dot,psi_dot
    T_matrix=[1, sin(phi)*tan(theta), cos(phi)*tan(theta); ...
        0, cos(phi), -sin(phi); ...
        0, sin(phi)*sec(theta), cos(phi)*sec(theta)];
    
    global omega_total
    
    % The nonlinear equation describing the dynamics of the drone
    dx(1,1)=(v*r-w*q)+g*sin(theta); %u_dot
    dx(2,1)=(w*p-u*r)-g*cos(theta)*sin(phi); %v_dot
    dx(3,1)=(u*q-v*p)-g*cos(theta)*cos(phi)+U1/m; %w_dot
    dx(4,1)=q*r*(Iy-Iz)/Ix-Jtp/Ix*q*omega_total+U2/Ix; %p_dot
    dx(5,1)=p*r*(Iz-Ix)/Iy+Jtp/Iy*p*omega_total+U3/Iy; %q_dot
    dx(6,1)=p*q*(Ix-Iy)/Iz+U4/Iz; %r_dot
    dx(7,1)=R_matrix(1,:)*[u;v;w]; %x_dot
    dx(8,1)=R_matrix(2,:)*[u;v;w]; %y_dot
    dx(9,1)=R_matrix(3,:)*[u;v;w]; %z_dot
    dx(10,1)=T_matrix(1,:)*[p;q;r]; %phi_dot
    dx(11,1)=T_matrix(2,:)*[p;q;r]; %theta_dot
    dx(12,1)=T_matrix(3,:)*[p;q;r]; %psi_dot
    
end





=========================

=========================

=========================


FILENAME: Matlab/init_constants.m

CONTENTS:


%% Project Made By HERAZ Walid as a bachelor graduation project at the Institute of Electrical and Electronic Engineering IGEE_ex_INELEC 2024, Algeria
%% Github : https://github.com/HerazWalid
%% LinkdIn : https://www.linkedin.com/in/walid-heraz-94337a240/



function constants=init_constants()
    
    % Constants 
    Ix = 0.0034; %kg*m^2
    Iy = 0.0034; %kg*m^2
    Iz = 0.006; %kg*m^2
    m  = 0.698; %kg
    g  = 9.81; %m/s^2
    Jtp=1.302*10^(-6); %N*m*s^2=kg*m^2
    Ts=0.1; %s
    
    % Matrix weights for the cost function (They must be diagonal)
    Q=[10 0 0;0 10 0;0 0 10]; % weights for outputs (output x output)
    S=[10 0 0;0 10 0;0 0 10]; % weights for the final horizon outputs (output x output)
    R=[10 0 0;0 10 0;0 0 10]; % weights for inputs (input x input)
    
    ct = 7.6184*10^(-8)*(60/(2*pi))^2; %N*s^2
    cq = 2.6839*10^(-9)*(60/(2*pi))^2; %N*m^2
    l = 0.171; %m;
    
    controlled_states=3;
    hz = 4; % horizon period
    
    innerDyn_length=4; % Number of inner control loop iterations
    
    px=[-1 -2];
    py=[-1 -2];
    pz=[-1 -2];
    
    % Choose your trajectory (1,2,3,4)
    trajectory=1;
    
    constants={Ix Iy Iz m g Jtp Ts Q S R ct cq l controlled_states hz innerDyn_length px py pz trajectory};

end




=========================

=========================

=========================


FILENAME: Matlab/trajectory_generator.m

CONTENTS:


function [X_ref,X_dot_ref,X_dot_dot_ref,Y_ref,Y_dot_ref,Y_dot_dot_ref,Z_ref,Z_dot_ref,Z_dot_dot_ref,psi_ref]=trajectory_generator(t,r,f,height_i,height_f)

constants = init_constants();
Ts=constants{7}; %s
innerDyn_length=constants{16}; % Number of inner control loop iterations
trajectory=constants{20};

alpha=2*pi*f*t;
d_height=height_f-height_i;

if trajectory==1
    x = 1.5 .* t / 10 + 1 + 2 * cos(t / 5);
    y = 1.5 .* t / 10 - 2 + 2 * sin(t / 5);
    z = height_i + d_height/t(end) * t + 20 * sin(0.3 * t);
    
elseif trajectory==2
    x = (r / 10 .* t + 2) .* cos(alpha + t / 5);
    y = (r / 10 .* t + 2) .* sin(alpha + t / 5);
    z = height_i + d_height/t(end) * t .* sin(t / 5);
    
elseif trajectory==3
    x = 2 .* t / 20 + 1 + cos(t / 2);
    y = 2 .* t / 20 - 2 + sin(t / 2);
    z = height_i + d_height/t(end) * t + 10 * sin(0.3 * t);
    
elseif trajectory==4
    
    x = -4 .* t / 20 + 1 + cos(t / 4);
    y = 2 .* t / 20 - 2 + sin(t / 4);
    z = height_i + d_height/t(end) * t + 5 * sin(0.3 * t);
end

dx=[x(2)-x(1),x(2:end)-x(1:end-1)];
dy=[y(2)-y(1),y(2:end)-y(1:end-1)];
dz=[z(2)-z(1),z(2:end)-z(1:end-1)];

x_dot=round(dx.*(1/(Ts*innerDyn_length)),8);
y_dot=round(dy.*(1/(Ts*innerDyn_length)),8);
z_dot=round(dz.*(1/(Ts*innerDyn_length)),8);


ddx=[x_dot(2)-x_dot(1),x_dot(2:end)-x_dot(1:end-1)];
ddy=[y_dot(2)-y_dot(1),y_dot(2:end)-y_dot(1:end-1)];
ddz=[z_dot(2)-z_dot(1),z_dot(2:end)-z_dot(1:end-1)];

x_dot_dot=round(ddx.*(1/(Ts*innerDyn_length)),8);
y_dot_dot=round(ddy.*(1/(Ts*innerDyn_length)),8);
z_dot_dot=round(ddz.*(1/(Ts*innerDyn_length)),8);


psi=zeros(1,length(x));
psiInt=psi;
psi(1)=atan2(y(1),x(1))+pi/2;
psi(2:end)=atan2(dy(2:end),dx(2:end));

dpsi=psi(2:end)-psi(1:end-1);

psiInt(1)=psi(1);
for i = 2:length(psiInt)
    if dpsi(i-1)<-pi
        psiInt(i)=psiInt(i-1)+(dpsi(i-1)+2*pi);
    elseif dpsi(i-1)>pi
        psiInt(i)=psiInt(i-1)+(dpsi(i-1)-2*pi);
    else
        psiInt(i)=psiInt(i-1)+dpsi(i-1);
    end
end
psiInt=round(psiInt,8);

X_ref = [t' x'];
X_dot_ref = [t' x_dot'];
X_dot_dot_ref = [t' x_dot_dot'];
Y_ref = [t' y'];
Y_dot_ref = [t' y_dot'];
Y_dot_dot_ref = [t' y_dot_dot'];
Z_ref = [t' z'];
Z_dot_ref = [t' z_dot'];
Z_dot_dot_ref = [t' z_dot_dot'];
psi_ref = [t' psiInt'];

end




=========================

=========================

=========================


